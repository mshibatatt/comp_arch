## 8.3
>ある種のCPUには「後方互換性」モードがあるといいます。
>そういうモードは、ユーザーにとってメリットがあるのでしょうか?




## 8.8
>16bit算術演算しか提供しないマイクロコントローラで32bit乗算を実行するための、
>マイクロコードのアルゴリズムを組みましょう。
>そして、作成したアルゴリズムをC言語のshort変数を使って実装しましょう。

16bitの乗算は最大で32bitの結果を返す必要がある.
問題文の「16bit算術演算を提供する」を、
16bit乗算が計算結果を16bitのレジスタ2つに上位下位の16bitを返すと仮定する.

p139の例にならい, 32bitオペランドが$R_1$, $R_2$ レジスタに格納されているとし,
それぞれの上位下位16bitを$r_1, r_2$と$r_3, r_4$ とする.
このときの32bit乗算は以下のように展開される.

|     | <br>✕  | r1<br>r3   | r2<br>r4   | 
| --- | --- | --- | --- | 
|     |     | r5  | r6  | 
|     | r7  | r8  |     | 
|     | r9  | r10 |     | 
| r11 | r12 |     |     | 
| --- | --- | --- | --- | 
| r13 | r14 | r15 | r16 | 

リスト8-1と同様に, キャリーに気をつけながら16bit加算を繰り返せばよい.
プログラムの実装は`8_8.cpp` を参照のこと.


## 8.12
>もしラスベガスのカジノがプログラム実行のオッズを計算したら、
>分岐が行われるほうに、どのくらいのオッズが付くと思いますか。説明もお願いします。

胴元の控除率が0とするならば, 期待値が1になるようにオッズがつくはずである.
教科書p150によれば、分岐はおよそ60%の確率で発生するので, 
オッズは $1 / 0.6 = 1.6666666\dots$
